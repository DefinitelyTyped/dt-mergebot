{
  "c5e5c9885d23e7d1c1ea8f54b53c8283d5f4f856:types/jasmine/tsconfig.json": "{\n    \"files\": [\n        \"index.d.ts\",\n        \"jasmine-tests.ts\"\n    ],\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"lib\": [\n            \"es6\",\n            \"dom\"\n        ],\n        \"noImplicitAny\": true,\n        \"noImplicitThis\": true,\n        \"strictNullChecks\": true,\n        \"baseUrl\": \"../\",\n        \"typeRoots\": [\n            \"../\"\n        ],\n        \"types\": [],\n        \"noEmit\": true,\n        \"forceConsistentCasingInFileNames\": true\n    }\n}\n",
  "master:types/jasmine/tsconfig.json": "{\n    \"files\": [\n        \"index.d.ts\",\n        \"jasmine-tests.ts\"\n    ],\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"lib\": [\n            \"es6\",\n            \"dom\"\n        ],\n        \"noImplicitAny\": true,\n        \"noImplicitThis\": true,\n        \"strictNullChecks\": true,\n        \"strictFunctionTypes\": false,\n        \"baseUrl\": \"../\",\n        \"typeRoots\": [\n            \"../\"\n        ],\n        \"types\": [],\n        \"noEmit\": true,\n        \"forceConsistentCasingInFileNames\": true\n    }\n}\n",
  "c5e5c9885d23e7d1c1ea8f54b53c8283d5f4f856:types/jasmine/tslint.json": "{\n    \"extends\": \"dtslint/dt.json\",\n    \"rules\": {\n        \"await-promise\": false,\n        \"ban-types\": false,\n        \"no-declare-current-package\": false,\n        \"no-empty-interface\": false,\n        \"no-single-declare-module\": false,\n        \"no-unnecessary-generics\": false,\n        \"no-var-keyword\": false,\n        \"one-variable-per-declaration\": false,\n        \"only-arrow-functions\": false\n    }\n}\n",
  "master:types/jasmine/tslint.json": "{\n    \"extends\": \"dtslint/dt.json\",\n    \"rules\": {\n        \"ban-types\": false,\n        \"no-declare-current-package\": false,\n        \"no-empty-interface\": false,\n        \"no-single-declare-module\": false,\n        \"no-unnecessary-generics\": false,\n        \"no-var-keyword\": false,\n        \"one-variable-per-declaration\": false,\n        \"only-arrow-functions\": false\n    }\n}\n",
  "master:types/jasmine/index.d.ts": "// Type definitions for Jasmine 3.6\n// Project: http://jasmine.github.io\n// Definitions by: Boris Yankov <https://github.com/borisyankov>\n//                 Theodore Brown <https://github.com/theodorejb>\n//                 David Pärsson <https://github.com/davidparsson>\n//                 Gabe Moothart <https://github.com/gmoothart>\n//                 Lukas Zech <https://github.com/lukas-zech-software>\n//                 Boris Breuer <https://github.com/Engineer2B>\n//                 Chris Yungmann <https://github.com/cyungmann>\n//                 Giles Roadnight <https://github.com/Roaders>\n//                 Yaroslav Admin <https://github.com/devoto13>\n//                 Domas Trijonis <https://github.com/fdim>\n//                 Moshe Kolodny <https://github.com/kolodny>\n//                 Stephen Farrar <https://github.com/stephenfarrar>\n//                 Alex Povar <https://github.com/zvirja>\n//                 Dominik Ehrenberg <https://github.com/djungowski>\n//                 Chives <https://github.com/chivesrs>\n//                 kirjs <https://github.com/kirjs>\n//                 Md. Enzam Hossain <https://github.com/ienzam>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\n// For ddescribe / iit use : https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/karma-jasmine/karma-jasmine.d.ts\n\n/**\n * @deprecated Use {@link jasmine.ImplementationCallback} instead.\n */\ntype ImplementationCallback = jasmine.ImplementationCallback;\n\n/**\n * Create a group of specs (often called a suite).\n * @param description Textual description of the group\n * @param specDefinitions Function for Jasmine to invoke that will define inner suites a specs\n */\ndeclare function describe(description: string, specDefinitions: () => void): void;\n\n/**\n * A focused `describe`. If suites or specs are focused, only those that are focused will be executed.\n * @param description Textual description of the group\n * @param specDefinitions Function for Jasmine to invoke that will define inner suites a specs\n */\ndeclare function fdescribe(description: string, specDefinitions: () => void): void;\n\n/**\n * A temporarily disabled `describe`. Specs within an xdescribe will be marked pending and not executed.\n * @param description Textual description of the group\n * @param specDefinitions Function for Jasmine to invoke that will define inner suites a specs\n */\ndeclare function xdescribe(description: string, specDefinitions: () => void): void;\n\n/**\n * Define a single spec. A spec should contain one or more expectations that test the state of the code.\n * A spec whose expectations all succeed will be passing and a spec with any failures will fail.\n * @param expectation Textual description of what this spec is checking\n * @param assertion Function that contains the code of your test. If not provided the test will be pending.\n * @param timeout Custom timeout for an async spec.\n */\ndeclare function it(expectation: string, assertion?: jasmine.ImplementationCallback, timeout?: number): void;\n\n/**\n * A focused `it`. If suites or specs are focused, only those that are focused will be executed.\n * @param expectation Textual description of what this spec is checking\n * @param assertion Function that contains the code of your test. If not provided the test will be pending.\n * @param timeout Custom timeout for an async spec.\n */\ndeclare function fit(expectation: string, assertion?: jasmine.ImplementationCallback, timeout?: number): void;\n\n/**\n * A temporarily disabled `it`. The spec will report as pending and will not be executed.\n * @param expectation Textual description of what this spec is checking\n * @param assertion Function that contains the code of your test. If not provided the test will be pending.\n * @param timeout Custom timeout for an async spec.\n */\ndeclare function xit(expectation: string, assertion?: jasmine.ImplementationCallback, timeout?: number): void;\n\n/**\n * Mark a spec as pending, expectation results will be ignored.\n * If you call the function pending anywhere in the spec body, no matter the expectations, the spec will be marked pending.\n * @param reason Reason the spec is pending.\n */\ndeclare function pending(reason?: string): void;\n\n/**\n * Sets a user-defined property that will be provided to reporters as\n * part of the properties field of SpecResult.\n * @since 3.6.0\n */\ndeclare function setSpecProperty(key: string, value: unknown): void;\n\n/**\n * Sets a user-defined property that will be provided to reporters as\n * part of the properties field of SuiteResult.\n * @since 3.6.0\n */\ndeclare function setSuiteProperty(key: string, value: unknown): void;\n\n/**\n * Run some shared setup before each of the specs in the describe in which it is called.\n * @param action Function that contains the code to setup your specs.\n * @param timeout Custom timeout for an async beforeEach.\n */\ndeclare function beforeEach(action: jasmine.ImplementationCallback, timeout?: number): void;\n\n/**\n * Run some shared teardown after each of the specs in the describe in which it is called.\n * @param action Function that contains the code to teardown your specs.\n * @param timeout Custom timeout for an async afterEach.\n */\ndeclare function afterEach(action: jasmine.ImplementationCallback, timeout?: number): void;\n\n/**\n * Run some shared setup once before all of the specs in the describe are run.\n * Note: Be careful, sharing the setup from a beforeAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.\n * @param action Function that contains the code to setup your specs.\n * @param timeout Custom timeout for an async beforeAll.\n */\ndeclare function beforeAll(action: jasmine.ImplementationCallback, timeout?: number): void;\n\n/**\n * Run some shared teardown once before all of the specs in the describe are run.\n * Note: Be careful, sharing the teardown from a afterAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.\n * @param action Function that contains the code to teardown your specs.\n * @param timeout Custom timeout for an async afterAll\n */\ndeclare function afterAll(action: jasmine.ImplementationCallback, timeout?: number): void;\n\n/**\n * Create an expectation for a spec.\n * @checkReturnValue see https://tsetse.info/check-return-value\n * @param spy\n */\ndeclare function expect<T extends jasmine.Func>(spy: T | jasmine.Spy<T>): jasmine.FunctionMatchers<T>;\n\n/**\n * Create an expectation for a spec.\n * @checkReturnValue see https://tsetse.info/check-return-value\n * @param actual\n */\ndeclare function expect<T>(actual: ArrayLike<T>): jasmine.ArrayLikeMatchers<T>;\n\n/**\n * Create an expectation for a spec.\n * @checkReturnValue see https://tsetse.info/check-return-value\n * @param actual Actual computed value to test expectations against.\n */\ndeclare function expect<T>(actual: T): jasmine.Matchers<T>;\n\n/**\n * Create an expectation for a spec.\n */\ndeclare function expect(): jasmine.NothingMatcher;\n\n/**\n * Create an asynchronous expectation for a spec. Note that the matchers\n * that are provided by an asynchronous expectation all return promises\n * which must be either returned from the spec or waited for using `await`\n * in order for Jasmine to associate them with the correct spec.\n * @checkReturnValue see https://tsetse.info/check-return-value\n * @param actual Actual computed value to test expectations against.\n */\ndeclare function expectAsync<T, U>(actual: T|PromiseLike<T>): jasmine.AsyncMatchers<T, U>;\n\n/**\n * Explicitly mark a spec as failed.\n * @param e Reason for the failure\n */\ndeclare function fail(e?: any): void;\n\n/**\n * Action method that should be called when the async work is complete.\n */\ninterface DoneFn extends Function {\n    (): void;\n\n    /** fails the spec and indicates that it has completed. If the message is an Error, Error.message is used */\n    fail: (message?: Error | string) => void;\n}\n\n/**\n * Install a spy onto an existing object.\n * @param object The object upon which to install the `Spy`.\n * @param method The name of the method to replace with a `Spy`.\n */\ndeclare function spyOn<T, K extends keyof T = keyof T>(\n    object: T, method: T[K] extends Function ? K : never,\n): jasmine.Spy<\n    T[K] extends jasmine.Func ? T[K] :\n    T[K] extends { new (...args: infer A): infer V } ? (...args: A) => V :\n    never\n>;\n\n/**\n * Install a spy on a property installed with `Object.defineProperty` onto an existing object.\n * @param object The object upon which to install the `Spy`.\n * @param property The name of the property to replace with a `Spy`.\n * @param accessType The access type (get|set) of the property to `Spy` on.\n */\ndeclare function spyOnProperty<T>(object: T, property: keyof T, accessType?: 'get' | 'set'): jasmine.Spy;\n\n/**\n * Installs spies on all writable and configurable properties of an object.\n * @param object The object upon which to install the `Spy`s.\n */\ndeclare function spyOnAllFunctions<T>(object: T): jasmine.SpyObj<T>;\n\ndeclare function runs(asyncMethod: Function): void;\ndeclare function waitsFor(latchMethod: () => boolean, failureMessage?: string, timeout?: number): void;\ndeclare function waits(timeout?: number): void;\n\ndeclare namespace jasmine {\n    type Func = (...args: any[]) => any;\n\n    // Use trick with prototype to allow abstract classes.\n    // More info: https://stackoverflow.com/a/38642922/2009373\n    type Constructor = Function & { prototype: any };\n\n    type ImplementationCallback = (() => PromiseLike<any>) | (() => void) | ((done: DoneFn) => void);\n\n    type ExpectedRecursive<T> = T | ObjectContaining<T> | AsymmetricMatcher<any> | {\n        [K in keyof T]: ExpectedRecursive<T[K]> | Any;\n    };\n    type Expected<T> = T | ObjectContaining<T> | AsymmetricMatcher<any> | Any | Spy | {\n        [K in keyof T]: ExpectedRecursive<T[K]>;\n    };\n    type SpyObjMethodNames<T = undefined> =\n        T extends undefined ?\n            (ReadonlyArray<string> | { [methodName: string]: any }) :\n            (ReadonlyArray<keyof T> | { [P in keyof T]?: T[P] extends Func ? ReturnType<T[P]> : any });\n\n    type SpyObjPropertyNames<T = undefined> =\n        T extends undefined ?\n                (ReadonlyArray<string> | { [propertyName: string]: any }) :\n                (Readonly",
  "c5e5c9885d23e7d1c1ea8f54b53c8283d5f4f856:types/jasmine/index.d.ts": "// Type definitions for Jasmine 3.6\n// Project: http://jasmine.github.io\n// Definitions by: Boris Yankov <https://github.com/borisyankov>\n//                 Theodore Brown <https://github.com/theodorejb>\n//                 David Pärsson <https://github.com/davidparsson>\n//                 Gabe Moothart <https://github.com/gmoothart>\n//                 Lukas Zech <https://github.com/lukas-zech-software>\n//                 Boris Breuer <https://github.com/Engineer2B>\n//                 Chris Yungmann <https://github.com/cyungmann>\n//                 Giles Roadnight <https://github.com/Roaders>\n//                 Yaroslav Admin <https://github.com/devoto13>\n//                 Domas Trijonis <https://github.com/fdim>\n//                 Moshe Kolodny <https://github.com/kolodny>\n//                 Stephen Farrar <https://github.com/stephenfarrar>\n//                 Alex Povar <https://github.com/zvirja>\n//                 Dominik Ehrenberg <https://github.com/djungowski>\n//                 Chives <https://github.com/chivesrs>\n//                 kirjs <https://github.com/kirjs>\n//                 Md. Enzam Hossain <https://github.com/ienzam>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\n// For ddescribe / iit use : https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/karma-jasmine/karma-jasmine.d.ts\n\n/**\n * @deprecated Use {@link jasmine.ImplementationCallback} instead.\n */\ntype ImplementationCallback = jasmine.ImplementationCallback;\n\n/**\n * Create a group of specs (often called a suite).\n * @param description Textual description of the group\n * @param specDefinitions Function for Jasmine to invoke that will define inner suites a specs\n */\ndeclare function describe(description: string, specDefinitions: () => void): void;\n\n/**\n * A focused `describe`. If suites or specs are focused, only those that are focused will be executed.\n * @param description Textual description of the group\n * @param specDefinitions Function for Jasmine to invoke that will define inner suites a specs\n */\ndeclare function fdescribe(description: string, specDefinitions: () => void): void;\n\n/**\n * A temporarily disabled `describe`. Specs within an xdescribe will be marked pending and not executed.\n * @param description Textual description of the group\n * @param specDefinitions Function for Jasmine to invoke that will define inner suites a specs\n */\ndeclare function xdescribe(description: string, specDefinitions: () => void): void;\n\n/**\n * Define a single spec. A spec should contain one or more expectations that test the state of the code.\n * A spec whose expectations all succeed will be passing and a spec with any failures will fail.\n * @param expectation Textual description of what this spec is checking\n * @param assertion Function that contains the code of your test. If not provided the test will be pending.\n * @param timeout Custom timeout for an async spec.\n */\ndeclare function it(expectation: string, assertion?: jasmine.ImplementationCallback, timeout?: number): void;\n\n/**\n * A focused `it`. If suites or specs are focused, only those that are focused will be executed.\n * @param expectation Textual description of what this spec is checking\n * @param assertion Function that contains the code of your test. If not provided the test will be pending.\n * @param timeout Custom timeout for an async spec.\n */\ndeclare function fit(expectation: string, assertion?: jasmine.ImplementationCallback, timeout?: number): void;\n\n/**\n * A temporarily disabled `it`. The spec will report as pending and will not be executed.\n * @param expectation Textual description of what this spec is checking\n * @param assertion Function that contains the code of your test. If not provided the test will be pending.\n * @param timeout Custom timeout for an async spec.\n */\ndeclare function xit(expectation: string, assertion?: jasmine.ImplementationCallback, timeout?: number): void;\n\n/**\n * Mark a spec as pending, expectation results will be ignored.\n * If you call the function pending anywhere in the spec body, no matter the expectations, the spec will be marked pending.\n * @param reason Reason the spec is pending.\n */\ndeclare function pending(reason?: string): void;\n\n/**\n * Sets a user-defined property that will be provided to reporters as\n * part of the properties field of SpecResult.\n * @since 3.6.0\n */\ndeclare function setSpecProperty(key: string, value: unknown): void;\n\n/**\n * Sets a user-defined property that will be provided to reporters as\n * part of the properties field of SuiteResult.\n * @since 3.6.0\n */\ndeclare function setSuiteProperty(key: string, value: unknown): void;\n\n/**\n * Run some shared setup before each of the specs in the describe in which it is called.\n * @param action Function that contains the code to setup your specs.\n * @param timeout Custom timeout for an async beforeEach.\n */\ndeclare function beforeEach(action: jasmine.ImplementationCallback, timeout?: number): void;\n\n/**\n * Run some shared teardown after each of the specs in the describe in which it is called.\n * @param action Function that contains the code to teardown your specs.\n * @param timeout Custom timeout for an async afterEach.\n */\ndeclare function afterEach(action: jasmine.ImplementationCallback, timeout?: number): void;\n\n/**\n * Run some shared setup once before all of the specs in the describe are run.\n * Note: Be careful, sharing the setup from a beforeAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.\n * @param action Function that contains the code to setup your specs.\n * @param timeout Custom timeout for an async beforeAll.\n */\ndeclare function beforeAll(action: jasmine.ImplementationCallback, timeout?: number): void;\n\n/**\n * Run some shared teardown once before all of the specs in the describe are run.\n * Note: Be careful, sharing the teardown from a afterAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.\n * @param action Function that contains the code to teardown your specs.\n * @param timeout Custom timeout for an async afterAll\n */\ndeclare function afterAll(action: jasmine.ImplementationCallback, timeout?: number): void;\n\n/**\n * Create an expectation for a spec.\n * @checkReturnValue see https://tsetse.info/check-return-value\n * @param spy\n */\ndeclare function expect<T extends jasmine.Func>(spy: T | jasmine.Spy<T>): jasmine.FunctionMatchers<T>;\n\n/**\n * Create an expectation for a spec.\n * @checkReturnValue see https://tsetse.info/check-return-value\n * @param actual\n */\ndeclare function expect<T>(actual: ArrayLike<T>): jasmine.ArrayLikeMatchers<T>;\n\n/**\n * Create an expectation for a spec.\n * @checkReturnValue see https://tsetse.info/check-return-value\n * @param actual Actual computed value to test expectations against.\n */\ndeclare function expect<T>(actual: T): jasmine.Matchers<T>;\n\n/**\n * Create an expectation for a spec.\n */\ndeclare function expect(): jasmine.NothingMatcher;\n\n/**\n * Create an asynchronous expectation for a spec. Note that the matchers\n * that are provided by an asynchronous expectation all return promises\n * which must be either returned from the spec or waited for using `await`\n * in order for Jasmine to associate them with the correct spec.\n * @checkReturnValue see https://tsetse.info/check-return-value\n * @param actual Actual computed value to test expectations against.\n */\ndeclare function expectAsync<T, U>(actual: T|PromiseLike<T>): jasmine.AsyncMatchers<T, U>;\n\n/**\n * Explicitly mark a spec as failed.\n * @param e Reason for the failure\n */\ndeclare function fail(e?: any): void;\n\n/**\n * Action method that should be called when the async work is complete.\n */\ninterface DoneFn extends Function {\n    (): void;\n\n    /** fails the spec and indicates that it has completed. If the message is an Error, Error.message is used */\n    fail: (message?: Error | string) => void;\n}\n\n/**\n * Install a spy onto an existing object.\n * @param object The object upon which to install the `Spy`.\n * @param method The name of the method to replace with a `Spy`.\n */\ndeclare function spyOn<T, K extends keyof T = keyof T>(\n    object: T, method: T[K] extends Function ? K : never,\n): jasmine.Spy<\n    T[K] extends jasmine.Func ? T[K] :\n    T[K] extends { new (...args: infer A): infer V } ? (...args: A) => V :\n    never\n>;\n\n/**\n * Install a spy on a property installed with `Object.defineProperty` onto an existing object.\n * @param object The object upon which to install the `Spy`.\n * @param property The name of the property to replace with a `Spy`.\n * @param accessType The access type (get|set) of the property to `Spy` on.\n */\ndeclare function spyOnProperty<T>(object: T, property: keyof T, accessType?: 'get' | 'set'): jasmine.Spy;\n\n/**\n * Installs spies on all writable and configurable properties of an object.\n * @param object The object upon which to install the `Spy`s.\n */\ndeclare function spyOnAllFunctions<T>(object: T): jasmine.SpyObj<T>;\n\ndeclare function runs(asyncMethod: Function): void;\ndeclare function waitsFor(latchMethod: () => boolean, failureMessage?: string, timeout?: number): void;\ndeclare function waits(timeout?: number): void;\n\ndeclare namespace jasmine {\n    type Func = (...args: any[]) => any;\n\n    // Use trick with prototype to allow abstract classes.\n    // More info: https://stackoverflow.com/a/38642922/2009373\n    type Constructor = Function & { prototype: any };\n\n    type ImplementationCallback = (() => PromiseLike<any>) | (() => void) | ((done: DoneFn) => void);\n\n    type ExpectedRecursive<T> = T | ObjectContaining<T> | AsymmetricMatcher<any> | {\n        [K in keyof T]: ExpectedRecursive<T[K]> | Any;\n    };\n    type Expected<T> = T | ObjectContaining<T> | AsymmetricMatcher<any> | Any | Spy | {\n        [K in keyof T]: ExpectedRecursive<T[K]>;\n    };\n    type SpyObjMethodNames<T = undefined> =\n        T extends undefined ?\n            (ReadonlyArray<string> | { [methodName: string]: any }) :\n            (ReadonlyArray<keyof T> | { [P in keyof T]?: T[P] extends Func ? ReturnType<T[P]> : any });\n\n    type SpyObjPropertyNames<T = undefined> =\n        T extends undefined ?\n                (ReadonlyArray<string> | { [propertyName: string]: any }) :\n                (Readonly"
}
