{
  "master:types/tabulator-tables/index.d.ts": "// Type definitions for tabulator-tables 4.7\n// Project: http://tabulator.info\n// Definitions by: Josh Harris <https://github.com/jojoshua>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.3\n\n// tslint:disable:max-line-length\n// tslint:disable:jsdoc-format\n// tslint:disable:no-trailing-whitespace\n\ndeclare namespace Tabulator {\n    interface Options\n        extends OptionsGeneral,\n            OptionsMenu,\n            OptionsHistory,\n            OptionsLocale,\n            OptionsDownload,\n            OptionsColumns,\n            OptionsRows,\n            OptionsData,\n            OptionsSorting,\n            OptionsFiltering,\n            OptionsRowGrouping,\n            OptionsPagination,\n            OptionsPersistentConfiguration,\n            OptionsClipboard,\n            OptionsDataTree,\n            OptionsCell,\n            OptionsCells,\n            OptionsHTML {}\n\n    interface OptionsCells extends CellCallbacks {\n        /** The validationFailed event is triggered when the value entered into a cell during an edit fails to pass validation. */\n        validationFailed?: (cell: CellComponent, value: any, validators: Validator[] | StandardValidatorType[]) => void;\n    }\n    interface OptionsDataTree {\n        /** To enable data trees in your table, set the dataTree property to true in your table constructor: */\n        dataTree?: boolean;\n        /**  By default the toggle element will be inserted into the first column on the table. If you want the toggle element to be inserted in a different column you can pass the feild name of the column to the dataTreeElementColumn setup option*/\n        dataTreeElementColumn?: boolean | string;\n        /** Show tree branch icon     */\n        dataTreeBranchElement?: boolean | string;\n        /** Tree level indent in pixels     */\n        dataTreeChildIndent?: number;\n        /** By default Tabulator will look for child rows in the _children field of a row data object. You can change this to look in a different field using the dataTreeChildField property in your table constructor: */\n        dataTreeChildField?: string;\n        /** The toggle button that allows users to collapse and expand the column can be customised to meet your needs. There are two options, dataTreeExpandElement and dataTreeCollapseElement, that can be set to replace the default toggle elements with your own.\n\n      Both options can take either an html string representing the contents of the toggle element */\n        dataTreeCollapseElement?: string | HTMLElement | boolean;\n        /** The toggle button that allows users to expand the column */\n        dataTreeExpandElement?: string | HTMLElement | boolean;\n        /**  By default all nodes on the tree will start collapsed, you can customize the initial expansion state of the tree using the dataTreeStartExpanded option.*\n        This option can take one of three possible value types, either a boolean to indicate whether all nodes should start expanded or collapsed: */\n        dataTreeStartExpanded?: boolean | boolean[] | ((row: RowComponent, level: number) => boolean);\n        /**Propagte selection events from parent rows to children */\n        dataTreeSelectPropagate?: boolean;\n    }\n    interface OptionsClipboard {\n        /** You can enable clipboard functionality using the clipboard config option. It can take one of four possible values:\n\n      true - enable clipboard copy and paste\n      \"copy\" - enable only copy functionality\n      \"paste\" - enable only paste functionality\n      false - disable all clipboard functionality (default) */\n        clipboard?: boolean | 'copy' | 'paste';\n\n        /**The clipboardCopyRowRange option takes a Row Range Lookup value and allows you to choose which rows are included in the clipboard output: */\n        clipboardCopyRowRange?: RowRangeLookup;\n\n        /**You can alter the finished output to the clipboard using the clipboardCopyFormatter callback. The callback function receives two arguments, the first is a string representing the type of content to be formatted (either \"plain\" or \"html\" depending on the type of data entering the clipboard). The second argument is the string that is about to be insered into the clipboard. The function and should return a string that will be inserted into the clipboard */\n        clipboardCopyFormatter?: 'table' | ((type: 'plain' | 'html', output: string) => string);\n        /** By default Tabulator will include the column header titles in any clipboard data, this can be turned off by passing a value of false to the clipboardCopyHeader property: */\n        clipboardCopyHeader?: boolean;\n        /**  Tabulator has one built in paste parser, that is designed to take a table formatted text string from the clipboard and turn it into row data. it breaks the tada into rows on a newline character \\n and breaks the rows down to columns on a tab character \\t.\n\n      It will then attempt to work out which columns in the data correspond to columns in the table. It tries three different ways to achieve this. First it checks the values of all columns in the first row of data to see if they match the titles of columns in the table. If any of the columns don't match it then tries the same approach but with the column fields. If either of those options match, Tabulator will map those columns to the incoming data and import it into rows. If there is no match then Tabulator will assume the columns in the data are in the same order as the visible columns in the table and import them that way.\n\n      The inbuilt parser will reject any clipboard data that does not contain at least one row and two columns, in that case the clipboardPasteError will be triggered.\n\n      If you extend the clipboard module to add your own parser, you can set it to be used as default with the clipboardPasteParser property.*/\n        clipboardPasteParser?: string | ((clipboard: any) => any[]);\n        /** Once the data has been parsed into row data, it will be passed to a paste action to be added to the table. There are three inbuilt paste actions:\n\n      insert - Inserts data into the table using the addRows function (default)\n      update - Updates data in the table using the updateOrAddData function\n      replace - replaces all data in the table using the setData function */\n        clipboardPasteAction?: 'insert' | 'update' | 'replace';\n\n        /** By default Tabulator will copy some of the tables styling along with the data to give a better visual appearance when pasted into other documents.\n\n    If you want to only copy the unstyled data then you should set the clipboardCopyStyled option to false in the table options object:  */\n        clipboardCopyStyled?: boolean;\n\n        /** By default Tabulator includes column headers, row groups and column calculations in the clipboard output.\n\n    You can choose to remove column headers groups, row groups or column calculations from the output data by setting the values in the clipboardCopyConfig option in the table definition: */\n        clipboardCopyConfig?: AddditionalExportOptions | boolean;\n\n        /** The clipboardCopied event is triggered whenever data is copied to the clipboard. */\n        clipboardCopied?: () => void;\n        /** The clipboardPasted event is triggered whenever data is successfuly pasted into the table. */\n        clipboardPasted?: () => void;\n        /** The clipboardPasteError event is triggered whenever an atempt to paste data into the table has failed because it was rejected by the paste parser. */\n        clipboardPasteError?: () => void;\n\n        /**When copying to clipboard you may want to apply a different group header from the one usualy used in the table. You can now do this using the groupHeaderClipboard table option, which takes the same inputs as the standard groupHeader property. */\n        groupHeaderClipboard?:\n            | ((value: any, count: number, data: any, group: GroupComponent) => string)\n            | Array<(value: any, count: number, data: any) => string>;\n\n        /**When the getHtml function is called you may want to apply a different group header from the one usualy used in the table. You can now do this using the groupHeaderHtmlOutput table option, which takes the same inputs as the standard groupHeader property. */\n        groupHeaderHtmlOutput?:\n            | ((value: any, count: number, data: any, group: GroupComponent) => string)\n            | Array<(value: any, count: number, data: any) => string>;\n    }\n\n    interface OptionsPersistentConfiguration {\n        /** ID tag used to identify persistent storage information     */\n        persistenceID?: string;\n        /**  Persistence information can either be stored in a cookie or in the localSotrage object, you can use the persistenceMode to choose which. It can take three possible values:\n\n      local - (string) Store the persistence information in the localStorage object\n      cookie - (string) Store the persistence information in a cookie\n      true - (boolean) check if localStorage is available and store persistence information, otherwise store in cookie (Default option)    */\n        persistenceMode?: 'local' | 'cookie' | true;\n        /** Enable persistsnt storage of column layout information     */\n        persistentLayout?: boolean;\n        /** You can ensure the data sorting is stored for the next page load by setting the persistentSort option to true */\n        persistentSort?: boolean;\n        /**  You can ensure the data filtering is stored for the next page load by setting the persistentFilter option to true*/\n        persistentFilter?: boolean;\n        /**By setting the persistence property to true the table will persist the sort, filter, group (groupBy, groupStartOpen, groupHeader), pagination (paginationSize), and column (title, width, visibility, order) configuration of the table */\n        persistence?: true | PersistenceOptions;\n        /**The persistenceWriterFunc function will receive three arguments, the persistance id of the table, the type of data to be written and an object or array representing the data */\n        persistenceWriterFunc?: (id: string, type: keyof PersistenceOptions, data: any) => any;\n        /**The persistenceReaderFunc func"
}